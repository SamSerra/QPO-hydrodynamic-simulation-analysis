import numpy as np
import matplotlib.pyplot as plt
import h5py
from scanf import scanf

"""
Module to Supplement main.py
"""
## Post Processing 
##---------------------------------------------------------------------##

class PPCLASS:
        """
        Post Process object
        """
        def __init__(self):
             self.mRootDirName = ''

             self.mNumZones = 0
             # Arrays for storing data
             self.mScalarFields = np.array([])
             self.mVectorFields = np.array([])

             # temp
             self.velocityField = np.array([])
             self.velocityX = np.array([])
             self.velocityY = np.array([])
             
             # Master file attributes
             self.mNumDomains = 0
             self.mDirNameArray = np.array([])
             self.mDimension = 0
             self.mNumNodesInZone = 8
             self.mNumScalarFields = 0
             self.mNumVectorFields = 0
             self.mScalarFieldNames = np.array([])
             self.mVectorFieldNames = np.array([])
             self.mNumTimeSteps = 0
             self.mDumpIDArray = np.array([])
             self.mCycleArray = np.array([])
             self.mTimeArray = np.array([])
             self.mDataFileNameArray = np.array([])
             self.mGridFileNameArray = np.array([])
        
        
        def readMasterFile(self, rootDir, fileStem = "Master"):
                """
                Read .cosmos++ file generated by simulation 
                
                MODIFICATIONS
                =================
                March 24, 2018  |  created
                March 25, 2018  |  changed to method
                """
                
                self.mRootDirName = rootDir
                fileName = rootDir + "/out-" + fileStem + ".cosmos++"
                with open(fileName) as f:
                        # Number of domains/directories
                        descriptor, ndomains = scanf("%s %i",f.readline())
                        self.mNumDomains = ndomains
                        print("\n{} {}".format(descriptor, self.mNumDomains))

                        # Directory names
                        descriptor, = scanf("%s", f.readline())
                        print("\n{}".format(descriptor))

                        for i in np.arange(self.mNumDomains):
                                name, = scanf("%s", f.readline())
                                self.mDirNameArray=np.append(self.mDirNameArray,name)
                                print("\n{}".format(name))

                        # Number of dimensions
                        descriptor, ndims = scanf("%s %i",f.readline())
                        self.mDimension = ndims
                        print("\n{} {}".format(descriptor, self.mDimension))

                        if(ndims==1): self.mNumNodesInZone = 2
                        if(ndims==2): self.mNumNodesInZone = 4

                        # Number of Output Fields
                        descriptor, nfields = scanf("%s %i", f.readline())
                        print("\n{} {}".format(descriptor,nfields))

                        # Field names
                        for i in np.arange(nfields):
                                descriptor, fieldname = scanf("%s %s",f.readline())

                                if(str(descriptor)==str("#SCALARFIELD")):
                                        self.mNumScalarFields += 1
                                        self.mScalarFieldNames=np.append(self.mScalarFieldNames,fieldname)
                                elif(str(descriptor)==str("#VECTORFIELD")):
                                        self.mNumVectorFields += 1
                                        self.mVectorFieldNames=np.append(self.mVectorFieldNames,fieldname)
                                else:
                                        print("WARNING: descriptor {} not defined".format(descriptor))
                                        exit(0)

                                print("\n{} {}".format(descriptor,fieldname))

                        # Timesteps
                        descriptor, ntimes = scanf("%s %i",f.readline())
                        self.mNumTimeSteps = ntimes
                        print("\n{} {}".format(descriptor,self.mNumTimeSteps))

                        # Descriptor for output
                        descriptor, = scanf("%s\n", f.readline())
                        print("{}".format(descriptor))

                        for i in np.arange(ntimes):
                                dump, cycle, time, fname, gname = scanf("%i %i %e %s %s", f.readline())
                                self.mDumpIDArray=np.append(self.mDumpIDArray, dump)
                                self.mCycleArray=np.append(self.mCycleArray, cycle)
                                self.mTimeArray=np.append(self.mTimeArray, time)
                                self.mDataFileNameArray=np.append(self.mDataFileNameArray, fname)
                                self.mGridFileNameArray=np.append(self.mGridFileNameArray, gname)

                                print("\n {} {} {} {} {}".format(dump,cycle,time,fname,gname))
                                
        def readData(self, dumpID):
                """
                Currently only reads velocity data. Will be extended in the future to read all data

                MODIFICATIONS
                ============
                March 25, 2018  |  created
                """

                # ndir1 and ndir2 are lower and upper bound of the processor
                # directories domain data to be read. ndir1 = 0 and ndir2 = mNumDomains
                # specifies to read the whole dataset
                ndir1 = 0
                ndir2 = self.mNumDomains
                nsets = self.mNumDomains / 1  # 1 will be replaced with mpi.getNumProcs in future

                ndims = self.mDimension

                vectorFieldOffset = 0
                icount = 0
                for idir in np.arange(ndir1,ndir2,1):
                        sfilename = self.mRootDirName + "/" + self.mDirNameArray[idir] + "/" + \
                                    self.mDataFileNameArray[dumpID]
                        datasetName = "Cosmos++"

                        # Open HDF5 File and read data/chunk size
                        dataf = h5py.File(sfilename, 'r')
                        data = dataf[datasetName]

                        chunkShape = data.chunks 
                        chunkSize = chunkShape[0]
                        print("Chunk size: {}".format(chunkSize))

                        # Get interal zone attribute
                        numInternalZones = data.attrs['Number of Internal Zones']
                        print("Number of Internal Zones: {}".format(numInternalZones))

                        self.mNumZones += numInternalZones

                        # Read vector field data
                        self.velocityField=np.append(self.velocityField, data[8*chunkSize:10*chunkSize])
                        # Update shift counters
                        vectorFieldOffset += chunkSize
                        #vectorFieldOffset += ndims*chunkSize
                        icount += 1
                self.velocityField = self.velocityField.flatten()
## Other
## ------------------------------------------------------------------##
def ConvertToPolar(nDims, xArray, yArray, zArray = np.zeros(1,)):
        """
        Takes in arrays of cartesian coordinates and transforms
        them to polar or spherical coordinates.
        Spherical coordinates set up as rho, phi, and theta (azimuth)

        Returns radius array, phi, theta array
        """
        assert xArray.shape == yArray.shape, "Array's must have same shape!"

        if nDims == 3:
                pass
        elif nDims == 2:
                zArray=np.zeros(xArray.shape)
                
        #create arrays for coordinates
        rho, phi, theta = np.ones(xArray.shape), np.ones(xArray.shape), np.ones(xArray.shape)
        
        rho=np.sqrt(xArray**2+yArray**2+zArray**2) #if 2-dimensional, rho == rad
        rad=np.sqrt(xArray**2+yArray**2)
        
        phi=np.arctan2(rad,zArray)
        
        theta=np.arctan2(yArray,xArray)

        return rho, phi, theta

def plot_polar_contour(values, theta, radius):
        """
        Takes in z,theta,r arrays
        Generates a polar contour plot symetric about theta = 0
        """
        theta = np.array(theta)
        radius = np.array(radius)

        values = np.array(values)
        values = values.reshape(len(theta), len(radius))

        r, tet = np.meshgrid(radius, theta)	#meshgrid set up opposite of values b/c pyplot uses transpose 

        print("Generating Plot...")	
        maxbound = np.max(theta)	#bounds for plot

        fig, ax = plt.subplots(subplot_kw=dict(projection='polar'))
        cax = ax.contourf(tet, r, values, 30, cmap = "hot", vmin = 1.0e-29, vmax = 1.0e-18)

        cb = fig.colorbar(cax)
        cb.set_label("Mass Density")

        x=ax.axes.get_xaxis()
        x.set_visible(False)

        plt.savefig('MassDensityContour.png', dpi = 600)
        print("Plot Saved")
        return fig, ax, cax
