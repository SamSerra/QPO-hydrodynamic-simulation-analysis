import numpy as np
import matplotlib.pyplot as plt
import h5py
from scanf import scanf
import sys

"""
Module to Supplement main.py
"""
## Post Processing 
##---------------------------------------------------------------------##

class PPCLASS:
        """
        Post Process object
        """
        def __init__(self):
             self.mRootDirName = ''

             self.mNumZones = 0
             # Arrays for storing data
             self.mScalarFields = np.array([])
             self.mVectorFields = np.array([])

             # Grid
             self.mNodePositions = np.array([])
             self.mZoneVolume = np.array([])
             self.mZoneLength = np.array([])
             self.mZoneCenter = np.array([])
             
             # temp
             self.velocityField = np.array([])
             self.velocityX = np.array([])
             self.velocityY = np.array([])
             
             # Master file attributes
             self.mNumDomains = 0
             self.mDirNameArray = np.array([])
             self.mDimension = 0
             self.mNumNodesInZone = 8
             self.mNumScalarFields = 0
             self.mNumVectorFields = 0
             self.mScalarFieldNames = np.array([])
             self.mVectorFieldNames = np.array([])
             self.mNumTimeSteps = 0
             self.mDumpIDArray = np.array([])
             self.mCycleArray = np.array([])
             self.mTimeArray = np.array([])
             self.mDataFileNameArray = np.array([])
             self.mGridFileNameArray = np.array([])

             # control
             self.isVerbose = False
        
        def readMasterFile(self, rootDir, fileStem = "Master"):
                """
                Read .cosmos++ file generated by simulation 
                
                MODIFICATIONS
                =================
                March 24, 2018  |  created
                March 25, 2018  |  changed to method
                """
                
                self.mRootDirName = rootDir
                fileName = rootDir + "/out-" + fileStem + ".cosmos++"
                with open(fileName) as f:
                        # Number of domains/directories
                        descriptor, ndomains = scanf("%s %i",f.readline())
                        self.mNumDomains = ndomains
                        if (self.isVerbose):
                                print("\n{} {}".format(descriptor, self.mNumDomains))

                        # Directory names
                        descriptor, = scanf("%s", f.readline())
                        if (self.isVerbose):
                                print("\n{}".format(descriptor))

                        for i in np.arange(self.mNumDomains):
                                name, = scanf("%s", f.readline())
                                self.mDirNameArray=np.append(self.mDirNameArray,name)
                                if (self.isVerbose):
                                        print("\n{}".format(name))

                        # Number of dimensions
                        descriptor, ndims = scanf("%s %i",f.readline())
                        self.mDimension = ndims
                        if (self.isVerbose):
                                print("\n{} {}".format(descriptor, self.mDimension))

                        if(ndims==1): self.mNumNodesInZone = 2
                        if(ndims==2): self.mNumNodesInZone = 4

                        # Number of Output Fields
                        descriptor, nfields = scanf("%s %i", f.readline())
                        if (self.isVerbose):
                                print("\n{} {}".format(descriptor,nfields))

                        # Field names
                        for i in np.arange(nfields):
                                descriptor, fieldname = scanf("%s %s",f.readline())

                                if(str(descriptor)==str("#SCALARFIELD")):
                                        self.mNumScalarFields += 1
                                        self.mScalarFieldNames=np.append(self.mScalarFieldNames,fieldname)
                                elif(str(descriptor)==str("#VECTORFIELD")):
                                        self.mNumVectorFields += 1
                                        self.mVectorFieldNames=np.append(self.mVectorFieldNames,fieldname)
                                else:
                                        print("WARNING: descriptor {} not defined".format(descriptor))
                                        exit(0)

                                if (self.isVerbose):
                                        print("\n{} {}".format(descriptor,fieldname))

                        # Timesteps
                        descriptor, ntimes = scanf("%s %i",f.readline())
                        self.mNumTimeSteps = ntimes
                        if (self.isVerbose):
                                print("\n{} {}".format(descriptor,self.mNumTimeSteps))

                        # Descriptor for output
                        descriptor, = scanf("%s\n", f.readline())
                        if (self.isVerbose):
                                print("{}".format(descriptor))

                        for i in np.arange(ntimes):
                                dump, cycle, time, fname, gname = scanf("%i %i %e %s %s", f.readline())
                                self.mDumpIDArray=np.append(self.mDumpIDArray, dump)
                                self.mCycleArray=np.append(self.mCycleArray, cycle)
                                self.mTimeArray=np.append(self.mTimeArray, time)
                                self.mDataFileNameArray=np.append(self.mDataFileNameArray, fname)
                                self.mGridFileNameArray=np.append(self.mGridFileNameArray, gname)

                                if (self.isVerbose):
                                        print("\n {} {} {} {} {}".format(dump,cycle,time,fname,gname))
                                
        def readData(self, dumpID):
                """
                Currently only reads velocity data. Will be extended in the future to read all data

                MODIFICATIONS
                ============
                March 25, 2018  |  created
                """

                # ndir1 and ndir2 are lower and upper bound of the processor
                # directories domain data to be read. ndir1 = 0 and ndir2 = mNumDomains
                # specifies to read the whole dataset
                ndir1 = 0
                ndir2 = self.mNumDomains
                nsets = self.mNumDomains / 1  # 1 will be replaced with mpi.getNumProcs in future

                ndims = self.mDimension

                # clear arrays
                self.mScalarFields = np.array([])
                self.mVectorFields = np.array([])
                self.mNodePositions = np.array([])
                self.mNumZones = 0
                
                # reshape field arrays to (number of fields by max size)
                maxArraySize = 288*288
                self.mScalarFields.resize((self.mNumScalarFields,maxArraySize))
                self.mVectorFields.resize((self.mNumVectorFields,maxArraySize))
                self.mNodePositions.resize(ndims*self.mNumNodesInZone*maxArraySize)
                
                chunkCount = 0
                scalarFieldOffset = 0 
                vectorFieldOffset = 0
                nodePositionOffset = 0
                icount = 0
                for idir in np.arange(ndir1,ndir2,1):
                        '''# progress bar
                        sys.stdout.write('\rReading Data from Domain {}/{}'.format(idir+1,ndir2))
                        sys.stdout.flush()
                        '''
                        
                        ## Fields
                        #----------------------------------
                        sfilename = self.mRootDirName + "/" + self.mDirNameArray[idir] + "/" + \
                                    self.mDataFileNameArray[dumpID]
                        datasetName = "Cosmos++"

                        # Open HDF5 File and read data/chunk size
                        dataf = h5py.File(sfilename, 'r')
                        data = dataf[datasetName]

                        chunkShape = data.chunks 
                        chunkSize = chunkShape[0]

                        # Get interal zone attribute
                        numInternalZones = data.attrs['Number of Internal Zones']

                        if (self.isVerbose):
                                print("Chunk size: {}".format(chunkSize))
                                print("Number of Internal Zones: {}".format(numInternalZones))

                        self.mNumZones += chunkSize #self.mNumZones += numInternalZones

                        # read mass density
                        self.mScalarFields[3,scalarFieldOffset:scalarFieldOffset+chunkSize] = data[3*chunkSize:4*chunkSize]
                        
                        # Read vector field data
                        #self.velocityField=np.append(self.velocityField, data[8*chunkSize:10*chunkSize])
                        ## Grid
                        #----------------------------------------
                        sfilename = self.mRootDirName + "/" + self.mDirNameArray[idir] + "/" + \
                                    self.mGridFileNameArray[dumpID]
                        datasetName = "Cosmos++"
                        
                        # Open HDF5 File and read data/chunk size
                        datafg = h5py.File(sfilename, 'r')
                        data = datafg[datasetName]

                        # Read node
                        self.mNodePositions[nodePositionOffset:nodePositionOffset+ndims*self.mNumNodesInZone*chunkSize] = data
                        
                        
                        # Update shift counters
                        scalarFieldOffset += chunkSize
                        vectorFieldOffset += ndims*chunkSize
                        nodePositionOffset += ndims*chunkSize*self.mNumNodesInZone
                        icount += 1
                        
                # Trim data arrays to length of total number of zones (chunk count)
                trimSize = np.arange(self.mNumZones,len(self.mScalarFields[0]))
                self.mScalarFields = np.delete(self.mScalarFields, trimSize, axis=1)
                self.mVectorFields = np.delete(self.mVectorFields, trimSize, axis=1)

                # Trim grid array
                trimSize = np.arange(ndims*self.mNumZones*self.mNumNodesInZone,len(self.mNodePositions))
                self.mNodePositions = np.delete(self.mNodePositions, trimSize, axis=0)

                # Clean up
                dataf.close()
                datafg.close()

                self.setZoneGeometry()
                
                
        def setZoneGeometry(self):
                ndims = self.mDimension
                
                # Resize arrays
                self.mZoneVolume.resize(self.mNumZones)
                self.mZoneLength.resize(self.mNumZones*ndims)
                self.mZoneCenter.resize(self.mNumZones*ndims)
                
                if(ndims==3):
                        pass
                elif(ndims==2):
                        ncnt=0
                        for n in np.arange(self.mNumZones):
                                xavg = .25*(self.mNodePositions[ncnt+0] + self.mNodePositions[ncnt+2]\
                                           + self.mNodePositions[ncnt+4] + self.mNodePositions[ncnt+6])
                                yavg = .25*(self.mNodePositions[ncnt+1] + self.mNodePositions[ncnt+3]\
                                           + self.mNodePositions[ncnt+5] + self.mNodePositions[ncnt+7])
                                dx = .5*(np.abs(self.mNodePositions[ncnt + 0] - xavg) + \
                                         np.abs(self.mNodePositions[ncnt + 2] - xavg) + \
                                         np.abs(self.mNodePositions[ncnt + 4] - xavg) + \
                                         np.abs(self.mNodePositions[ncnt + 6] - xavg))

                                dy = .5*(np.abs(self.mNodePositions[ncnt + 1] - yavg) + \
                                         np.abs(self.mNodePositions[ncnt + 3] - yavg) + \
                                         np.abs(self.mNodePositions[ncnt + 5] - yavg) + \
                                         np.abs(self.mNodePositions[ncnt + 7] - yavg))

                                self.mZoneVolume[n] = dx*dy
                                
                                self.mZoneLength[n*ndims + 0] = dx
                                self.mZoneLength[n*ndims + 1] = dy
                                
                                self.mZoneCenter[n*ndims + 0] = xavg
                                self.mZoneCenter[n*ndims + 1] = yavg

                                ncnt += ndims*self.mNumNodesInZone
                elif(ndims==1):
                        pass
                else:
                        print("****ERROR-volume: mDimension is incorrect")
                        sys.exit(0)
        
#--------------------------------------------------------------------------------
        def getCurrentTime(self, dumpID): return self.mTimeArray[dumpID]
        
## Other
## ------------------------------------------------------------------##
def ConvertToPolar(nDims, xArray, yArray, zArray = np.zeros(1,)):
        """
        Takes in arrays of cartesian coordinates and transforms
        them to polar or spherical coordinates.
        Spherical coordinates set up as rho, phi, and theta (azimuth)

        Returns radius array, phi, theta array
        """
        assert xArray.shape == yArray.shape, "Array's must have same shape!"

        if nDims == 3:
                pass
        elif nDims == 2:
                zArray=np.zeros(xArray.shape)
                
        #create arrays for coordinates
        rho, phi, theta = np.ones(xArray.shape), np.ones(xArray.shape), np.ones(xArray.shape)
        
        rho=np.sqrt(xArray**2+yArray**2+zArray**2) #if 2-dimensional, rho == rad
        rad=np.sqrt(xArray**2+yArray**2)
        
        phi=np.arctan2(rad,zArray)
        
        theta=np.arctan2(yArray,xArray)

        return rho, phi, theta

def plot_polar_contour(values, theta, radius):
        """
        Takes in z,theta,r arrays
        Generates a polar contour plot symetric about theta = 0
        """
        theta = np.array(theta)
        radius = np.array(radius)

        values = np.array(values)
        values = values.reshape(len(theta), len(radius))

        r, tet = np.meshgrid(radius, theta)	#meshgrid set up opposite of values b/c pyplot uses transpose 

        print("Generating Plot...")	
        maxbound = np.max(theta)	#bounds for plot

        fig, ax = plt.subplots(subplot_kw=dict(projection='polar'))
        cax = ax.contourf(tet, r, values, 30, cmap = "hot", vmin = 1.0e-29, vmax = 1.0e-18)

        cb = fig.colorbar(cax)
        cb.set_label("Mass Density")

        x=ax.axes.get_xaxis()
        x.set_visible(False)

        plt.savefig('MassDensityContour.png', dpi = 600)
        print("Plot Saved")
        return fig, ax, cax
