import numpy as np
import matplotlib.pyplot as plt
import h5py
from scanf import scanf

"""
Module to Supplement main_pp.py
"""
## Post Processing 
##---------------------------------------------------------------------##

class PPCLASS:
        """
        Post Process object
        """
        def __init__(self):
             self.mRootDirName = ''

             # Master file attributes
             self.mNumDomains = 0
             self.mDirNameArray = []
             self.mDimension = 0
             self.mNumNodesInZone = 8
             self.mNumScalarFields = 0
             self.mNumVectorFields = 0
             self.mScalarFieldNames = []
             self.mVectorFieldNames = []
             self.mNumTimeSteps = 0
             self.mDumpIDArray = []
             self.mCycleArray = []
             self.mDataFileNameArray = []
             self.mGridFileNameArray = []
        
        
        def readMasterFile(self, rootDir, fileStem = "Master"):
                """
                Read .cosmos++ file generated by simulation 
                """
                self.mRootDirName = rootDir
                fileName = rootDir + "out-" + fileStem + ".cosmos++"
                with open(fileName) as f:
                        # Number of domains/directories
                        descriptor, ndomains = scanf("%s %i",f.readline())
                        self.mNumDomains = ndomains
                        print("\n{} {}".format(descriptor, self.mNumDomains))

                        # Directory names
                        descriptor = scanf("%s", line)
                        print("\n{}".format(descriptor))

                        for i in np.arange(self.mNumDomains):
                                name = scanf("%s", f.readline())
                                self.mDirNameArray.append(name)
                                print("{}{}".format(name))

                        # Number of dimensions
                        descriptor, ndims = scanf("%s %i",f.readline())
                        self.mDimension = ndims
                        print("\n{} {}".format(descriptor, self.mDimension))

                        if(ndims==1): self.mNumNodesInZone = 2
                        if(ndims==2): self.mNumNodesInZone = 4

                        # Number of Output Fields
                        descriptor, nfields = scanf("%s %i", f.readline())
                        print("\n{} {}".format(descriptor,nfields))

                        # Field names
                        for i in np.arange(nfields):
                                descriptor, fieldname = scanf("%s %s",f.readline())

                                if(str(descriptor)==str("#SCALARFIELD")):
                                        self.mNumScalarFields += 1
                                        self.mScalarFieldNames.append(fieldname)
                                elif(str(descriptor)==str("#VECTORFIELD")):
                                        self.mNumVectorFields += 1
                                        self.mVectorFieldNames.append(fieldname)
                                else:
                                        print("WARNING: descriptor {} not defined".format(descriptor))
                                        exit(0)

                                        print("\n{} {}".format(descriptor,fieldname))

                        # Timesteps
                        descriptor, ntimes = scanf("%s %i",f.readline())
                        self.mNumTimeSteps = ntimes
                        print("\n{} {}".format(descriptor,self.mNumTimeSteps))

                        # Descriptor for output
                        descriptor = scanf("%s\n", f.readline())
                        print("{}".format(descriptor))

                        for i in np.arange(ntimes):
                                dump, cycle, time, fname, gname = scanf("%i %i %e %s %s", f.readline())
                                self.mDumpIDArray.append(dump)
                                self.mCycleArray.append(cycle)
                                self.mTimeArray.append(time)
                                self.mDataFileNameArray.append(fname)
                                self.mGridFileNameArray.append(gname)

## Other
## ------------------------------------------------------------------##
def ConvertToPolar(nDims, xArray, yArray, zArray = np.zeros(1,)):
        """
        Takes in arrays of cartesian coordinates and transforms
        them to polar or spherical coordinates.
        Spherical coordinates set up as rho, phi, and theta (azimuth)

        Returns radius array, phi, theta array
        """
        assert xArray.shape == yArray.shape, "Array's must have same shape!"

        if nDims == 3:
                pass
        elif nDims == 2:
                zArray=np.zeros(xArray.shape)
                
        #create arrays for coordinates
        rho, phi, theta = np.ones(xArray.shape), np.ones(xArray.shape), np.ones(xArray.shape)
        
        rho=np.sqrt(xArray**2+yArray**2+zArray**2) #if 2-dimensional, rho == rad
        rad=np.sqrt(xArray**2+yArray**2)
        
        phi=np.arctan2(rad,zArray)
        
        theta=np.arctan2(yArray,xArray)

        return rho, phi, theta

def plot_polar_contour(values, theta, radius):
        """
        Takes in z,theta,r arrays
        Generates a polar contour plot symetric about theta = 0
        """
        theta = np.array(theta)
        radius = np.array(radius)

        values = np.array(values)
        values = values.reshape(len(theta), len(radius))

        r, tet = np.meshgrid(radius, theta)	#meshgrid set up opposite of values b/c pyplot uses transpose 

        print("Generating Plot...")	
        maxbound = np.max(theta)	#bounds for plot

        fig, ax = plt.subplots(subplot_kw=dict(projection='polar'))
        cax = ax.contourf(tet, r, values, 30, cmap = "hot", vmin = 1.0e-29, vmax = 1.0e-18)

        cb = fig.colorbar(cax)
        cb.set_label("Mass Density")

        x=ax.axes.get_xaxis()
        x.set_visible(False)

        plt.savefig('MassDensityContour.png', dpi = 600)
        print("Plot Saved")
        return fig, ax, cax
